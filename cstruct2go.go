package main

import (
	"bufio"
	"flag"
	"fmt"
	"io"
	"log"
	"os"
	"os/exec"
	"path/filepath"
	"regexp"
	"strconv"
	"strings"
)

var typeEquivalents map[string]string = map[string]string{
	"bool":     "bool",
	"int":      "int",
	"int8_t":   "int8",
	"int16_t":  "int16",
	"int32_t":  "int32",
	"int64_t":  "int64",
	"uint8_t":  "uint8",
	"uint16_t": "uint16",
	"uint32_t": "uint32",
	"uint64_t": "uint64",
	"char":     "byte",
	"char*":    "string",
	"float":    "float32",
	"double":   "float64",
}

func check(e error) {
	if e != nil {
		panic(e)
	}
}

type StructField struct {
	Name      string
	CType     string
	IsPointer bool
	IsArray   bool
	ArraySize int
}

type StructDef struct {
	Name   string
	Fields []StructField
}

func main() {
	input_file := flag.String("i", "./test_structs.h", "Input file")
	output_file := flag.String("o", "", "Output file, will have the same name as the input file if not set")
	package_name := flag.String("p", "main", "Package name")
	enable_format := flag.Bool("f", true, "Set to false if you do not want to format the file(or go is not installed on the system")
	flag.Parse()
	out_file := ""
	if *output_file == "" {
		out_file = filepath.Base(*input_file)
	} else {
		out_file = *output_file
	}
	out_file = strings.TrimSuffix(out_file, filepath.Ext(out_file))
	out_file = fmt.Sprintf("%s.go", out_file)
	all_structs := createStructsFromFile(*input_file)
	all_structs = fixPointersAndArrays(all_structs)
	writeToFile(all_structs, out_file, *package_name)
	if *enable_format {
		formatFile(out_file)
	}

}

func fixPointersAndArrays(sts []StructDef) []StructDef {
	for _, st := range sts {
		for index, field := range st.Fields {
			match, _ := regexp.MatchString("([a-z]+)\\[\\d\\]", field.Name)
			if match {
				split := strings.Split(field.Name, "[")
				field.Name = split[0]
				field.IsArray = true
				field.ArraySize, _ = strconv.Atoi(strings.TrimSuffix(split[1], "]"))
			}

			if strings.HasPrefix(field.Name, "*") {
				field.Name = strings.TrimPrefix(field.Name, "*")
				field.IsPointer = true
			}
			st.Fields[index] = field
		}
	}
	return sts
}

func formatFile(filename string) {
	cmd := exec.Command("go", "fmt", filename)
	err := cmd.Run()
	check(err)
}

func writeToFile(defs []StructDef, filename string, packageName string) {
	file, err := os.Create(filename)
	check(err)
	defer file.Close()
	io.WriteString(file, fmt.Sprintf("package %s\n\n", packageName))
	io.WriteString(file, "// WARNING: THIS IS AN AUTOGENERATED FILE, DO NOT EDIT!!\n")
	io.WriteString(file, "//\n")
	io.WriteString(file, "// This file was generated using cstruct2go(http://github.com/shrikantpatnaik/cstruc2go)\n")
	io.WriteString(file, "//\n")
	for _, st := range defs {
		io.WriteString(file, fmt.Sprintf("type %s struct {\n", st.Name))
		for _, field := range st.Fields {
			fieldtype := typeEquivalents[field.CType]
			if field.IsArray == true {
				fieldtype = fmt.Sprintf("[%d]%s", field.ArraySize, fieldtype)
			}
			if field.IsPointer == true {
				fieldtype = fmt.Sprintf("*%s", fieldtype)
			}
			io.WriteString(file, fmt.Sprintf("\t%s %s\n", field.Name, fieldtype))
		}
		io.WriteString(file, "}\n")
	}
}
func createStructsFromFile(filename string) []StructDef {

	var struct_decl bool = false
	var struct_begin bool = false

	var current_struct *StructDef
	var all_structs []StructDef = make([]StructDef, 0, 100)

	file, err := os.Open(filename)
	if err != nil {
		log.Fatal(err)
	}
	defer file.Close()

	scanner := bufio.NewScanner(file)
	for scanner.Scan() {
		line := strings.Replace(scanner.Text(), "\t", "  ", -1)
		if line == "typedef struct" {
			struct_decl = true
		} else if struct_decl == true {
			if line == "{" {
				struct_begin = true
				current_struct = new(StructDef)
				current_struct.Fields = make([]StructField, 0, 100)
			} else if strings.Contains(line, "}") {
				s := splitAndRemoveInitialSpaces(line)
				newStructDef := current_struct
				newStructDef.Name = trimSemiColons(s[1])
				length := len(all_structs)
				all_structs = all_structs[0 : length+1]
				all_structs[length] = *newStructDef
				struct_begin = false
			} else if struct_begin == true {
				s := splitAndRemoveInitialSpaces(line)
				length := len(current_struct.Fields)
				current_struct.Fields = current_struct.Fields[0 : length+1]
				current_struct.Fields[length] = StructField{Name: trimSemiColons(s[1]), CType: s[0]}
			}
		}
	}

	if err := scanner.Err(); err != nil {
		log.Fatal(err)
	}

	return all_structs
}

func trimSemiColons(str string) string {
	return strings.Trim(str, ";")
}

func splitAndRemoveInitialSpaces(str string) []string {
	s := strings.Split(str, " ")
	i := 0
	for s[i] == "" {
		i++
	}
	return s[i:]

}
